@inherits IndexBase
@page "/"

<div id="sticky">
    <h1>CRAM IT!</h1>

    @if ( ! SettingOptions)
    {
        <button class="options-button" @onclick="ToggleSettingOptions">Options</button>

        @switch (Mode)
        {
            case Mode.SelectingDesiredOutput:
                <div class="target-item-category-choice">
                    @switch (TargetItemCategory)
                    {
                        case TargetItemCategory.TR:
                            <div class="category category-selected">TRs</div><!--
                            --><div class="category category-unselected" @onclick="() => {TargetItemCategory = TargetItemCategory.NotTR;}">Others</div>
                            break;
                        case TargetItemCategory.NotTR:
                            <div class="category category-unselected" @onclick="() => {TargetItemCategory = TargetItemCategory.TR;}">TRs</div><!--
                            --><div class="category category-selected">Others</div>
                            break;
                        default:
                            throw new Exception($@"Unhandled {nameof(Core.TargetItemCategory)} ""{TargetItemCategory}"" in switch");
                    }
                </div>
                break;
            case Mode.SelectingInputs:
            case Mode.SelectionComplete:
                <div class="summary-panel">
                    <div class="item-choice-outer recipe-choice target-item">
                        <div class="item-choice-inner">
                            <div class="item-sprite" style="@TargetItem.HtmlSpriteStyle"></div>
                            <br />
                            @TargetItem.ToString()
                        </div>
                    </div>
                    <div class="already-chosen-items">
                        @for (int i = 0; i < NumberOfItemsPerBatch; ++i)
                        {
                            if (InputItemSlots[i] is null)
                            {
                                string outerDivClassList =
                                    "chosen-item-slot-outer chosen-item-slot-outer-not-yet-chosen" + (i == 0 ? " chosen-item-slot-outer-first" : "");
                                <div class="@outerDivClassList">
                                    <div class="item-sprite chosen-item-slot-icon" style="@Item.PlaceholderHtmlSpriteStyle"></div>
                                    <div class="chosen-item-slot-name chosen-item-slot-name-not-yet-chosen">Not chosen yet</div>
                                </div>
                            }
                            else
                            {
                                var outerDivClassList = new List<string> {"chosen-item-slot-outer"};
                                outerDivClassList.Add(
                                    StandardRecipeGroupItemFilterer.ItemIsOfPlacatoryTypeForAllRecipes(InputItemSlots[i]) ?
                                        "chosen-item-slot-outer-already-chosen-of-placatory-type-for-all-recipes" :
                                    StandardRecipeGroupItemFilterer.ItemIsOfPlacatoryTypeForAnyRecipe(InputItemSlots[i]) ?
                                        "chosen-item-slot-outer-already-chosen-of-placatory-type-for-some-but-not-all-recipes" :
                                    "chosen-item-slot-outer-already-chosen-not-of-placatory-type-for-any-recipe"
                                );
                                if (i == 0)
                                {
                                    outerDivClassList.Add("chosen-item-slot-outer-first");
                                }

                                <div class="@string.Join(" ", outerDivClassList)">
                                    <div class="item-sprite chosen-item-slot-icon" style="@InputItemSlots[i].HtmlSpriteStyle"></div>
                                    <div class="chosen-item-slot-name chosen-item-slot-name-already-chosen">@InputItemSlots[i].ToString(InputItemOptions.CombineGroupsOfSimilarItems)</div>
                                    @{
                                        int i_Uncaptured = i;
                                    }
                                    <button @onclick="() => InputItemUnchosen(i_Uncaptured)" class="unchoose-item-button">&times;</button>
                                </div>
                            }
                        }
                    </div>
                    <div class="button-container-clear-and-restart">
                        @if (AnyInputItemsChosen)
                        {
                            <button @onclick="OnClear" class="clear-button">Clear</button>
                        }
                        else
                        {
                            <button @onclick="OnClear" class="clear-button" disabled>Clear</button>
                        }
                        <button @onclick="OnRestart" class="restart-button">Restart</button>
                    </div>
                </div>
                break;
            default:
                throw new Exception($@"Unhandled {nameof(CramIt.Site.Mode)} ""{Mode}"" in switch");
        }
    }
</div>

@if (SettingOptions)
{
    <input type="checkbox" @bind="Option_IncludeIrreplaceableInputItems" />
    @:Include irreplaceable input items<br />
    <input type="checkbox" @bind="Option_CombineGroupsOfSimilarInputItems" />
    @:Combine groups of similar input items<br />

    <!-- Todo: Find out if there is a way to do radio buttons that isn't shit -->

    @:Ordering of TRs:<br />

    @if (Option_TROrdering == TROrdering.ByMoveName)
    {
        <input type="radio"
               name="TROrdering"
               value="ByMoveName"
               checked
               @onchange="eventArgs => {Option_TROrdering = TROrdering.ByMoveName;}"
               />
    }
    else
    {
        <input type="radio"
               name="TROrdering"
               value="ByMoveName"
               @onchange="eventArgs => {Option_TROrdering = TROrdering.ByMoveName;}"
               />
    }
    @TROrdering.ByMoveName.HumanReadableName()<br />

    @if (Option_TROrdering == TROrdering.ByNumber)
    {
        <input type="radio"
               name="TROrdering"
               value="ByNumber"
               checked
               @onchange="eventArgs => {Option_TROrdering = TROrdering.ByNumber;}" />
    }
    else
    {
        <input type="radio"
               name="TROrdering"
               value="ByNumber"
               @onchange="eventArgs => {Option_TROrdering = TROrdering.ByNumber;}"
               />
    }
    @TROrdering.ByNumber.HumanReadableName()<br />

    @if (Option_TROrdering == TROrdering.ByMoveTypeThenMoveName)
    {
        <input type="radio"
               name="TROrdering"
               value="ByMoveTypeThenMoveName"
               checked
               @onchange="eventArgs => {Option_TROrdering = TROrdering.ByMoveTypeThenMoveName;}"
               />
    }
    else
    {
        <input type="radio"
               name="TROrdering"
               value="ByMoveTypeThenMoveName"
               @onchange="eventArgs => {Option_TROrdering = TROrdering.ByMoveTypeThenMoveName;}"
               />
    }
    @TROrdering.ByMoveTypeThenMoveName.HumanReadableName()<br />

    @if (Option_TROrdering == TROrdering.ByMoveTypeThenNumber)
    {
        <input type="radio"
               name="TROrdering"
               value="ByMoveTypeThenNumber"
               checked
               @onchange="eventArgs => {Option_TROrdering = TROrdering.ByMoveTypeThenNumber;}"
               />
    }
    else
    {
        <input type="radio"
               name="TROrdering"
               value="ByMoveTypeThenNumber"
               @onchange="eventArgs => {Option_TROrdering = TROrdering.ByMoveTypeThenNumber;}"
               />
    }
    @TROrdering.ByMoveTypeThenNumber.HumanReadableName()<br />
    
    @:Ordering of input items:<br />

    @if (Option_InputItemOrdering == InputItemOrdering.ByName)
    {
        <input type="radio"
               name="InputItemOrdering"
               value="ByName"
               checked
               @onchange="eventArgs => {Option_InputItemOrdering = InputItemOrdering.ByName;}"
               />
    }
    else
    {
        <input type="radio"
               name="InputItemOrdering"
               value="ByName"
               @onchange="eventArgs => {Option_InputItemOrdering = InputItemOrdering.ByName;}"
               />
    }
    @InputItemOrdering.ByName.HumanReadableName()<br />

    @if (Option_InputItemOrdering == InputItemOrdering.ByValue)
    {
        <input type="radio"
               name="InputItemOrdering"
               value="ByValue"
               checked
               @onchange="eventArgs => {Option_InputItemOrdering = InputItemOrdering.ByValue;}"
               />
    }
    else
    {
        <input type="radio"
               name="InputItemOrdering"
               value="ByValue"
               @onchange="eventArgs => {Option_InputItemOrdering = InputItemOrdering.ByValue;}" />
    }
    @InputItemOrdering.ByValue.HumanReadableName()<br />

    @if (Option_InputItemOrdering == InputItemOrdering.ByViabilityCategoryThenName)
    {
        <input type="radio"
               name="InputItemOrdering"
               value="ByViabilityCategoryThenName"
               checked
               @onchange="eventArgs => {Option_InputItemOrdering = InputItemOrdering.ByViabilityCategoryThenName;}"
               />
    }
    else
    {
        <input type="radio"
               name="InputItemOrdering"
               value="ByViabilityCategoryThenName"
               @onchange="eventArgs => {Option_InputItemOrdering = InputItemOrdering.ByViabilityCategoryThenName;}"
               />
    }
    @InputItemOrdering.ByViabilityCategoryThenName.HumanReadableName()<br />

    @if (Option_InputItemOrdering == InputItemOrdering.ByViabilityCategoryThenValue)
    {
        <input type="radio"
               name="InputItemOrdering"
               value="ByViabilityCategoryThenValue"
               checked
               @onchange="eventArgs => {Option_InputItemOrdering = InputItemOrdering.ByViabilityCategoryThenValue;}"
               />
    }
    else
    {
        <input type="radio"
               name="InputItemOrdering"
               value="ByViabilityCategoryThenValue"
               @onchange="eventArgs => {Option_InputItemOrdering = InputItemOrdering.ByViabilityCategoryThenValue;}"
               />
    }
    @InputItemOrdering.ByViabilityCategoryThenValue.HumanReadableName()<br />

    @if (Option_InputItemOrdering == InputItemOrdering.ByViabilityCategoryThenValueExceptThatNonviableItemsAreOrderedByName)
    {
        <input type="radio"
               name="InputItemOrdering"
               value="ByViabilityCategoryThenValueExceptThatNonviableItemsAreOrderedByName"
               checked
               @onchange="eventArgs => {Option_InputItemOrdering = InputItemOrdering.ByViabilityCategoryThenValueExceptThatNonviableItemsAreOrderedByName;}"
               />
    }
    else
    {
        <input type="radio"
               name="InputItemOrdering"
               value="ByViabilityCategoryThenValueExceptThatNonviableItemsAreOrderedByName"
               @onchange="eventArgs => {Option_InputItemOrdering = InputItemOrdering.ByViabilityCategoryThenValueExceptThatNonviableItemsAreOrderedByName;}"
               />
    }
    @InputItemOrdering.ByViabilityCategoryThenValueExceptThatNonviableItemsAreOrderedByName.HumanReadableName()<br />

    <button @onclick="ToggleSettingOptions">Done</button>
}
else
{
    <div>
        @switch (Mode)
        {
            case Mode.SelectingDesiredOutput:
                <div class="item-choice-list">
                    @switch (TargetItemCategory)
                    {
                        case TargetItemCategory.NotTR:
                            @foreach (var recipe in Recipes.StandardRecipesExcludingTRs.OrderBy(kvp => kvp.Key))
                            {
                                <div class="item-choice-outer recipe-choice" @onclick="() => RecipeClicked(recipe.Value)">
                                    <div class="item-choice-inner">
                                        <div class="item-sprite" style="@recipe.Value.First().Item.HtmlSpriteStyle"></div>
                                        <br />
                                        @recipe.Value.First().Item.ToString()
                                    </div>
                                </div>
                            }
                            break;
                        case TargetItemCategory.TR:
                            @foreach (var recipe in Recipes.TRRecipes.Values.ApplyOrdering(Option_TROrdering))
                            {
                                <div class="item-choice-outer recipe-choice" @onclick="() => RecipeClicked(recipe)">
                                    <div class="item-choice-inner">
                                        <div class="item-sprite" style="@recipe.Item.HtmlSpriteStyle"></div>
                                        <br />
                                        @recipe.Item.ToString()
                                    </div>
                                </div>
                            }
                            break;
                        default:
                            throw new Exception($@"Unhandled {nameof(Core.TargetItemCategory)} ""{TargetItemCategory}"" in switch");
                    }
                </div>
                break;
            case Mode.SelectingInputs:
                <div class="item-choice-list">
                    @{
                        var inputItemValueContributionDivStyle_MinimumMarker =
                            AlreadyChosenInputItemsTotalValue < TargetRecipes[0].MinimumTotalValue ?
                            InputItemValueContributionDivStyle_MinimumMarker() :
                            "";
                    }
                    @foreach (var candidate in Items.InputItems(
                        InputItemOptions, StandardRecipeGroupItemFilterer).ApplyOrdering(Option_InputItemOrdering))
                    {
                        if (candidate.Item == TargetItem)
                        {
                            continue;
                        }

                        string viabilityClassName = candidate.BestViabilityCategory.CssClassName("input-item-choice");
                        if (candidate.BestViabilityCategory == InputItemViabilityCategory.Viable_OfPlacatoryType)
                        {
                            viabilityClassName += StandardRecipeGroupItemFilterer.TypedInputRequiredForAnyRecipe ? "-type-matters" : "-type-doesnt-matter";
                        }

                        <div class="item-choice-outer input-item-choice @viabilityClassName" @onclick="() => InputItemChosen(candidate.Item)">
                            <div class="item-choice-inner">
                                <div class="item-sprite" style="@candidate.Item.HtmlSpriteStyle"></div>
                                <br />
                                @candidate.Item.ToString(InputItemOptions.CombineGroupsOfSimilarItems)
                            </div>
                            @if (TargetRecipes.Count == 1 && AlreadyChosenInputItemsTotalValue <= TargetRecipes[0].MaximumTotalValue)
                            {
                                <div class="value-contribution-div-outer">
                                    @if (AlreadyChosenInputItemsTotalValue + candidate.Item.Value > TargetRecipes[0].MaximumTotalValue)
                                    {
                                        <div class="value-contribution-div-inner-too-much"></div>
                                    }
                                    else
                                    {
                                        <div class="value-contribution-div-inner" style="@InputItemValueContributionDivStyle_Inner(candidate.Item)"></div>
                                        @if (AlreadyChosenInputItemsTotalValue < TargetRecipes[0].MinimumTotalValue)
                                        {
                                            <div class="value-contribution-div-minimum-marker" style="@inputItemValueContributionDivStyle_MinimumMarker"></div>
                                        }
                                    }
                                </div>
                            }
                        </div>
                    }
                </div>
                break;
            case Mode.SelectionComplete:
                break;
            default:
                throw new Exception($@"Unhandled {nameof(CramIt.Site.Mode)} ""{Mode}"" in switch");
        }
    </div>
}
